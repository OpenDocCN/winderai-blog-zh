# Go-Micro 观点和例子

> 原文：<https://winder.ai/go-micro-opinions-and-examples/>

我最近进行了一个四小时的限时高峰，以研究另一个 Go 微服务框架。 [Go-Micro](https://github.com/micro/micro) 是一个“微服务的 RPC 框架”。它旨在提供微服务部署中经常使用的通用组件。它标榜自己提供了一个[可插拔架构](https://github.com/micro/go-micro/tree/32f9546ed5ae9f7d654b8f2dde8251f58b6d917f#go-micro----)，并吹嘘了一长串[兼容性](https://github.com/micro/go-micro/tree/32f9546ed5ae9f7d654b8f2dde8251f58b6d917f#how-does-it-work)。

**过期警告**

这一页已经过时了。本文中的讨论点和链接可能不再有效。

## 新用户

新用户首先会注意到的是缺少文档。有[几个例子](https://github.com/micro/go-micro/tree/32f9546ed5ae9f7d654b8f2dde8251f58b6d917f/examples)和一些有见地的[博文](https://blog.micro.mu/)。但唯一的正式文件是回购首页的自述文件。

go-micro 的架构类似于一个分层堆栈，并通过五种不同类型的插件来分离关注点。顶层由客户机-服务器模型和服务抽象组成。

服务可以被定义为具有接口、输入和输出的协议缓冲文件。您也可以手动编写定义。这为应用程序的其余部分创建了一个可靠的接口。proto 文件被转换成可用的 go 代码，但是这只有在 protobuf 库的相关分支中才有可能。我假设这是因为一些非标准的代码生成。但我更希望它能以更稳定的方式包装。

## 首次申请

go-micro readme 上的[第一个示例](https://github.com/micro/go-micro/tree/32f9546ed5ae9f7d654b8f2dde8251f58b6d917f#define-the-service)应用程序提供了 go-micro 服务概念的简化演示。该示例实现了服务原型文件中的一个接口，并注册了该实现以供使用。

这个例子使用 protobuf RPC 调用进行通信。也就是说，您还需要启动一个可以访问原型模式的客户端服务来测试它。我认为这不是一个很好的初始例子，因为用户没有办法从外部验证服务。典型的 hello world 微服务示例通常是基于 REST 的，因此用户可以`curl`或打开浏览器来查看结果。快速“感觉良好”的实验对用户体验很重要。

此外，该示例默认使用 Consul 进行服务注册和发现。如果没有运行 Consul 服务器，应用程序将会崩溃。我不认为在这个级别的例子中添加这个要求是必要的或者明智的。有一个关于覆盖发现机制以使用嵌入式 DNS 服务器的说明，但是如果我不想使用任何东西呢？我不喜欢固执己见的工作流，尤其是在这样一个简单的例子中。

最后，我喜欢在这样的例子中看到代码可伸缩性的演示。这通常通过封装来实现；无论是在代码层面还是在架构层面。当我开始编辑简单的例子时，这并不清楚。例如，当我考虑端点时，它被放在主文件中，而不是单独的类中。这显然可以通过更干净的开发来解决，但是如果能从一开始就看到展示这种封装的博客文章/例子就更好了。

## 后续步骤

在最初的例子之后，接下来我想实现典型的 REST 微服务演示。首先，没有使用 go-micro 作为 REST 客户端的文档、例子或博客文章。其思想是 REST 服务应该只是基于 RPC 的服务的代理。

傲慢地说，自述文件引导我找到了一个名为 micro/go-web 的包(现已不存在)。它标榜自己是“go-micro 客户端注册、心跳和初始化的包装器”，我错误地认为这意味着我应该用`web.NewService`替换核心`micro.NewService`。我很困惑为什么这些包中有重复的代码，既没有标志选项，也没有能够传递给服务客户端的`Server`实现。

在对 micro 的 slack 通道进行了一些非常有益的讨论后，我发现 go-micro 服务和 go-web web 服务是不兼容的。这些不能一起使用。相反，我们的目的是让您单独使用 go-web 包。

go-web 服务的实现与 go-micro 截然不同。它没有一个清晰的服务抽象，就像我认为的服务一样。相反，服务实现是在 web 处理器中处理的。很像标准的`net/http`包。我显然不喜欢这样，因为它否定了服务抽象带来的所有封装好处。

此时我又卡住了，请求帮助。另一个建议是使用另一个 http 实现，我试过了，但结果是相同的架构。go-micro 服务必须单独使用。到目前为止，我认为不可能(或者至少很难)做到我想做的事情。我认为这是最基本的微服务例子。

## 意见

我的看法是 go-micro 太固执己见了。go-micro 强加的一些选择是有价值的想法。例如，我完全同意，如果您正在开发一个内部微服务应用程序，那么使用 REST 就没有什么意义。使用二进制协议，由于定义良好的接口和模式，可以提高性能和稳定性。RPC 是编码有状态决策的好方法。但是我不想被迫用 protobufs 来使用 RPC。我可能想使用 REST，特别是考虑到 REST 例子的流行。

这意味着“可插性”和它提供的所有特性只有在你同意框架的观点时才是可用的。事实上，我花了四个小时编写代码，却没有一个可用的 REST 示例，这让我非常失望，并且明显影响了我对框架的看法。

## 积极点！

我总是意识到批评写下来听起来很刺耳。我执行这个评估是为了确定这个框架和其他 Go 微服务框架之间的差异。很明显，我不同意框架中的一些相同观点，但这并不意味着这里没有好的工作。对其他微服务工具的支持列表可能是投资一些时间来看看它是否符合您的需求的真正原因。对于其他框架，您需要花费时间来实现支持。这意味着你可以节省大量的工时，只需简单地接受一些意见。

此外，我喜欢使用 proto 文件来指定服务接口的想法。这大大减少了样板文件的数量。我并不完全喜欢协议缓冲区的使用，也不喜欢我必须使用协议缓冲区的事实，但是我确实喜欢代码生成和封装。

我也和一些开发人员谈论过 Slack。他们很友好，在我愚蠢的努力中帮助了我；谢谢他们。