# 如何在微服务架构中进行测试

> 原文：<https://winder.ai/how-to-test-in-a-microservices-architecture/>

由于被测代码的分布式特性，微服务的测试本质上比整体测试更困难。但是分布式应用是值得追求的，因为根据定义，它们是解耦的和可伸缩的。

有了计划，结果就是一条自动保证质量的管道。在较大的项目中，质量的自动化保证变得越来越重要，因为没有人想要或者能够保证整个应用程序的质量。

这篇文章提供了我在使用微服务架构开发一系列软件时开发的一些指南。我试图将这些概念与最佳实践(本文末尾的参考资料)结合起来，但是有些术语是我自己的。

## 测试范围

测试的范围应该是有限的。这减少了要测试的代码量，从而减少了开发人员不提供全面覆盖的机会。它还减少了被测代码的边界，这意味着减少了依赖性和由外部来源引起的问题。大的边界会受到成比例的大量变化的影响，其中任何一个变化都可能破坏测试。

Mike Cohn 引入了测试金字塔的概念，这意味着测试的数量应该与测试的范围成比例。这是由于两个原因。我们希望确保代码的高测试覆盖率，因此拥有许多不经常改变的重点明确的单元测试是至关重要的(术语介绍很快)。我们想要更少的用户级测试，因为它们往往很慢(设置和运行)并且更脆弱(对 api 的更改可能会完全破坏整个工作流)。

如果我们考虑开发人员何时使用单元测试，何时使用用户级测试，这就更容易想象了。单元测试用于验证新的功能，并确保保留以前的功能。用户级测试是为了确保用户能够遵循工作流，并且满足需求。单元测试很少改变，因为代码库的大部分将保持静态。但是用户测试可能经常改变，因为它们经常与大量的功能代码相关联(尝试减少这种情况！).因此，拥有大量的单元测试和尽可能少的用户测试是更安全和明智的。

下面是测试范围的列表，从最小的、最集中的测试开始，到最大的、包罗万象的测试结束。

### 单位

单元测试关注技术。他们的目标是快速验证功能。它们是 TDD 的产物，但是在研究驱动的开发中，它们通常是用来补充代码的。确保测试尽可能的小和集中(以同样的方式代码应该是内聚的)允许容易的重构。单元测试被用作开发人员的安全网，以确保功能不会因开发人员的更改而被无意中更改。

### 成分

在没有外部依赖的情况下测试服务。例如，在不需要外部数据库的情况下测试有状态服务。使用嘲弄或模拟的版本。要测试的项目:

*   合同
*   内部主题的布线
*   类间通信和依赖性

### 容器(或等效的二进制文件)

将服务作为一个容器，用它们的外部依赖项进行测试。仅测试特定于服务的任务。无需启动整个应用程序。例如，用一个真实的 DB 容器并通过使用它们的外部 API 来测试有状态服务。要测试的项目:

*   失败状态:当依赖项不可用(例如，没有数据库)时会发生什么？
*   应用程序接口
*   使用案例

### 应用程序或端到端测试

验证应用程序在目标平台上作为一个整体工作。要测试的项目:

*   开始了吗？
*   它不会崩溃吗？
*   部署脚本工作了吗？
*   部署平台是否响应迅速？
*   非功能性测试，如性能
*   任何公共 API

### 用户

从用户的角度来看，应用程序是功能性的吗？要测试的项目:

*   UI 测试–链接检查–点击测试–用例测试
*   与用户交互相关的工作流。例如，创建帐户、添加到购物车、结帐购物车、订购、删除帐户。
*   需求测试

## 多少次测试？

根据经验，我使用行覆盖率来决定单元测试的数量。大多数人建议保持测试尽可能的干净和有凝聚力，但是根据我的经验，生命(或期限)太短了。

实际上，我发现测试永远不够。即使存在重复或不必要的测试，它们消耗的微小存储、精神负担和 cpu 周期也不值得花费时间来寻找它们并删除它们，直到它们开始引起问题(即，它们不工作或它们是古怪的)。

除非你预期你的单元测试将被用作文档；例如，在公共图书馆项目中。在这种情况下，明智的做法是尽量减少单元测试的数量，以帮助用户浏览代码。

我通常会让工程师判断花时间改进测试是否值得。我会考虑应用程序的整体信心；我是否有足够的信心说，如果我发布了，我会很高兴一切都按预期进行？如果不是，那么考虑提高测试的数量/质量。

## 测试环境

不同的环境测试不同的范围。下表强调了最重要的环境。最被低估的环境之一是登台。如果经过测试的服务被自动部署到试运行阶段，这就给了工程师一个在提升到生产阶段之前验证其代码的平台。允许工程师自己在这些环境中执行“冒烟”测试促进了服务的所有权(DevOps)。

| 环境 | 责任 | 水平映射 |
| --- | --- | --- |
| 当地的 | 发展 | 单位 |
| 建设 | 建筑规范和容器 | 单元、组件 |
| 测试 | 用于测试容器和应用程序的临时基础设施 | 容器、应用程序、用户 |
| 脚手架 | 快照部署的永久基础架构 |  |
| 生产 | 静态生产部署 |  |

## 管道

管道提供了代码到产品的持续集成和交付。它们自动接受新代码，这减少了测试负担，并促进了新代码的所有权。

所有事件最初都是由源代码管理存储库触发的。下面是将产生结果的存储库操作表。

| 行动 | 要求 | 工作 |
| --- | --- | --- |
| 在拉取请求中提交(PR) |  | 构建分支，部署到测试 |
| 在主机中提交/合并 | 公关部门通过测试。代码已审核。 | 构建快照，部署到测试 |
| 主提交通过测试 |  | 部署到暂存 |
| 源代码管理版本 | 硕士通过考试。手动烟雾测试完成。 | 构建标记版本，部署到测试，部署到生产 |

我们可以把桌子倒过来。环境将在以下情况下触发:

| 环境 | 触发于 |
| --- | --- |
| 当地的 |  |
| 建设 | 分支/主/标记中的新提交 |
| 测试 | 成功构建分支/快照/标记 |
| 脚手架 | 快照测试成功 |
| 生产 | 源代码管理版本 |

## 测试门

优选地，所有步骤将与源代码控制集成。例如，您不能合并 PR，直到分支已经建立并成功部署到测试中。

通常，在以下情况下，您可以继续执行以下步骤:

| 步骤 | 继续做 |
| --- | --- |
| 生产 | 人工质量保证验收后 |
| 脚手架 | 在主分支上成功测试之后 |
| 测试 | 成功构建后 |
| 建设 | 在成功的单元和组件测试和新的 PR 之后 |

## 进一步阅读

有一些非常好的新书。

Sam Newman 的“构建微服务”有一个关于测试的章节。

[Eberhard Wolff 的《微服务》](http://amzn.to/2cXz7vE)涵盖了大致相同的内容。

最后， [Adrian Mouat 的《使用 Docker》](http://amzn.to/2cpjRWm)提供了一个使用 Jenkins 的“走查”风格的例子(呸！).